/*
 * Helper program to generate a specific number of page faults. The program can be used to test the
 * eBPF program that counts page faults.
 * 
 * Note that the number of page faults generated by this program is not exact. The actual number of
 * page faults generated may be a bit different than the specified number due to the way the kernel handles
 * page faults.
 *
 * Usage: ./page_fault_gen <num_page_faults>
 *
 * DO NOT EDIT THIS CODE!
*/
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>
#include <sys/mman.h>

#define PAGE_SIZE 4096  // Usually 4KB

// Size of the program itself
#define PROG_SIZE 42 // The program itself generates +/- 42 page faults so we need to subtract this from the input

void generate_page_faults(size_t num_pages, size_t prog_size) {
    // Allocate memory (mmap ensures it's demand-paged)
    char *buffer = mmap(NULL, num_pages * PAGE_SIZE, PROT_READ | PROT_WRITE,
                        MAP_PRIVATE | MAP_ANONYMOUS, -1, 0);
    
    if (buffer == MAP_FAILED) {
        perror("mmap failed");
        exit(EXIT_FAILURE);
    }

    printf("Generating %zu page faults...\n", num_pages + prog_size);

    // Touch each page to trigger a page fault
    for (size_t i = 0; i < num_pages; i++) {
        buffer[i * PAGE_SIZE] = 1;  // Write to each page
    }

    printf("Done! %zu pages accessed.\n", num_pages + prog_size);

    // Free the memory
    munmap(buffer, num_pages * PAGE_SIZE);
}

int main(int argc, char *argv[]) {
    if (argc != 2) {
        fprintf(stderr, "Usage: %s <num_page_faults>\n", argv[0]);
        return EXIT_FAILURE;
    }
    // Check if below 50 pages, if so, exit
    size_t num_pages = strtoul(argv[1], NULL, 10);
    if (num_pages < 50) {
        fprintf(stderr, "Number of page faults must be at least 50\n");
        return EXIT_FAILURE;
    }
    // Subtract the program size from the input
    num_pages = num_pages - PROG_SIZE;
    
    generate_page_faults(num_pages, PROG_SIZE);

    return EXIT_SUCCESS;
}